# Реализованные методы
- GeneratePresetImpl
- SimulateBattleImpl
- SuitableForAttackUnitsFinderImpl
- UnitTargetPathFinderImpl

## GeneratePresetImpl
Метод отвечает за создание армии противника. Этапами его работы являются:
1. Оценка и сортировка списка юнитов. Поскольку на текущий момент предполагается всего четыре типа юнитов, вне зависимости от будущей численности армии, этот этап всегда будет занимать одинаковое время, что означает, что этот этап можно оценить как O(1), тем более, что он не зависит от m (количества юнитов в будущей армии) и выполняется только один раз в вспомогательных целях.
2. Набор армии - в данном алгоритме он выполняется m раз - то есть то количество, которое требуется для того, чтобы набрать полную армию.

Таким образом, итоговая сложность алгоритма составляет O(m), так как мы проходимся одним циклом по списку юнитов, который необходим для набора армии, вместо того, чтобы в цикле на каждом шаге проходиться по всем юнитам.

## SimulateBattleImpl
Метод отвечает за проведение симуляции боя. В его работе можно выделить следующие этапы:
1. Предварительная (одноразовая) сортировка всех юнитов на поле боя. Её сложность - O(n log n), но её можно относительно принять за константу, так как в цикле симуляции боя она не используется.
2. Проведение симуляции - для каждого юнита применяется метод атаки. Сложность - O(n), так как нагрузка на алгоритм пропорциональна количеству юнитов.
3. Исключение погибших юнитов - сложность n в квадрате, так как для каждого погибшего юнита (а в худшем случае это все юниты) необходимо провести операцию удаления из списка, которая выполняется за n.

Итоговая сложность в зависимости от того, считаем мы первый шаг за O(1) или за O(n log n) относительно всего алгоритма, будет либо O(n в квадрате) либо O(n в квадрате * n log n).

## SuitableForAttackUnitsFinderImpl
Алгоритм занимается определением подходящих для атаки юнитов.

Поскольку количество рядов фиксировано (равно трем), то сложность алгоритма определяется только количеством юнитов, по которым мы проходимся циклом (пусть и дважды - один раз для формирования сетки, второй раз - для самого определения подходящих юнитов).

Таким образом, итоговая сложность алгоритма O(n).

## UnitTargetPathFinderImpl
Метод отвечает за поиск кратчайшего пути между атакующим юнитом и целью на прямоугольном игровом поле. В основе алгоритма лежит алгоритм A* с использованием эвристической функции расстояния. В его работе можно выделить следующие этапы:

1. Создание поля - двумерного массива размером width × height и выполнение прохода по всем существующим юнитам для пометки занятых клеток.
Данный этап выполняется за O(width · height).

2. Основной этап поиска пути (алгоритм из теории графов - A*). Алгоритм последовательно извлекает клетки из очереди с приоритетом и рассматривает их соседей (до 8 направлений для каждой клетки).
В худшем случае каждая клетка поля может быть: добавлена в очередь, извлечена из очереди, обработана один раз. Каждое добавление и извлечение элемента из PriorityQueue выполняются за O(log width · height).

3. После достижения целевой клетки путь восстанавливается по карте предков cameFrom. Длина пути в худшем случае пропорциональна количеству клеток поля, поэтому сложность этого этапа составляет O(width · height).

Итоговая алгоритмическая сложность O((width · height) · log(width · height)).